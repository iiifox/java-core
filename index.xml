<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java 核心技术</title>
    <link>https://iiifox.github.io/java-core/</link>
    <description>Recent content on Java 核心技术</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 18 Jul 2022 21:28:26 +0800</lastBuildDate><atom:link href="https://iiifox.github.io/java-core/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1、异常体系结构</title>
      <link>https://iiifox.github.io/java-core/03_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/1%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 18 Jul 2022 17:56:00 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/03_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/1%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</guid>
      <description> java.lang.Throwable java.lang.Error：一般不编写针对性的代码进行处理 java.lang.Exception：可以进行异常的处理 编译时异常(checked) IOException FileNotFoundException ClassNotFoundException 运行时异常(unchecked) NullPointerException ArrayIndexOutOfBoundsException ClassCastException NumberFormatException InputMismatchException ArithmeticException </description>
    </item>
    
    <item>
      <title>1、面向过程与面向对象</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/1%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 18 Jul 2022 17:41:57 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/1%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>面向过程(POP)与面向对象(OOP) 二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。 面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。 面向对象的三大特征 封装性 继承性 多态性 面向对象的思想概述 程序员从面向过程的 执行者 转化成了面向对象的 指挥者 面向对象分析方法分析问题的思路和步骤： 根据问题需要，选择问题所针对的 现实世界的实体。 从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了 概念世界中的类。 把抽象的实体用计算机语言进行描述，形成计算机世界中的类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。 把 类实例化成计算机世界中的对象。对象是计算机世界中解决问题的最终工具。 </description>
    </item>
    
    <item>
      <title>1、关键字与保留字</title>
      <link>https://iiifox.github.io/java-core/01_java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/1%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97/</link>
      <pubDate>Mon, 18 Jul 2022 16:52:42 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/01_java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/1%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97/</guid>
      <description>关键字的定义和特点 被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词） 关键字中所有字母都为小写 保留字的定义 现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。命名标识符时要避免使用这些保留字。 总结：48个关键字、2个保留字、3个字面值
用于定义数据类型的关键字 class interface enum byte short int long float double char boolean void 用于定义流程控制的关键字 if else switch case default while do for break continue return 用于定义访问权限修饰符的关键字 private protected public 用于定义类，函数，变量修饰符的关键字 abstract final static synchronized 用于定义类与类之间关系的关键字 extends implements 用于定义建立实例及引用实例，判断实例的关键字 new this super instanceof 用于异常处理的关键字 try catch finally throw throws 用于包的关键字 package import 其他修饰符关键字 native strictfp transient volatile assert 保留字 goto const 用于定义数据类型值的字面值 true false null </description>
    </item>
    
    <item>
      <title>2、异常处理的方式一：try Catch Finally</title>
      <link>https://iiifox.github.io/java-core/03_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/2%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%80try-catch-finally/</link>
      <pubDate>Mon, 18 Jul 2022 17:55:43 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/03_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/2%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%80try-catch-finally/</guid>
      <description>try { //可能出现异常的代码 } catch (异常类型1 变量名1) { //处理异常的方式1 } catch (异常类型2 变量名2) { //处理异常的方式2 } catch (异常类型3 变量名3) { //处理异常的方式3 } ...... finally { //一定会执行的代码 } try-catch-finally的说明 使用try将可能出现异常代码包装起来。在执行过程之，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配 一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（在没有写finally的情况）。继续执行其后的代码 catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓；如果满足子父类关系，则要求子类一定声明在父类的上面，否则报错。 常用的异常对象处理的方式： String getMessage() printStackTrace() 在try结构中声明的变量，在出了try结构以后，就不能再被调用 try-catch-finally结构可以嵌套 try-catch-finally的体会 使用try-catch-finally处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。 开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。针对编译时异常，我们一定要考虑异常的处理。 finally的说明 finally是可选的 finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。 像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在finally中。 </description>
    </item>
    
    <item>
      <title>2、Java语言基本元素：类和对象</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/2java%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Mon, 18 Jul 2022 17:41:29 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/2java%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</guid>
      <description>类和对象 类(Class)和对象(Object)是面向对象的核心概念。 类是对一类事物的描述，是 抽象的、概念上的定义 对象是 实际存在的 的该类事物的每个个体，因而也称为 实例。 类和对象的使用（面向对象思想落地的实现） 创建类，设计类的成员 创建类的对象 通过&amp;quot;对象.属性&amp;quot;或&amp;quot;对象.方法&amp;quot;调用对象的结构 如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的(非static的)属性。意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。
对象的创建和使用：内存解析 堆(Heap)，此内存区域的唯一目的就是 存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。 通常所说的 栈(Stack)，是指虚拟机栈。虚拟机栈用于 存储局部变量 等。局部变量表存放了编译期可知长度的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不等同于对象本身，是对象在堆内存的首地址)。方法执行完，自动释放。 方法区(Method Area)，用于存储已被虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码 等数据 </description>
    </item>
    
    <item>
      <title>2、标识符</title>
      <link>https://iiifox.github.io/java-core/01_java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/2%E6%A0%87%E8%AF%86%E7%AC%A6/</link>
      <pubDate>Mon, 18 Jul 2022 16:52:32 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/01_java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/2%E6%A0%87%E8%AF%86%E7%AC%A6/</guid>
      <description>标识符的定义 Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符 技巧：凡是自己可以起名字的地方都叫标识符
定义合法标识符规则 由26个英文字母大小写，0-9，_或$组成 数字不可以开头 不可以使用关键字和保留字，但能包含关键字和保留字 Java 中严格区分大小写，长度无限制 标识符不能包含空格 Java中的名称命名规范 包名：多单词组成时所有字母都小写：xxxyyyzzz 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz 常量名：所有字母都大写，多单词时每个单词用下划线连接：XXX_YYY_ZZZ 注意点： 1、在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。 2、Java 采用 Unicode 字符集，因此标识符也可以使用汉字声明，但是不建议使用。</description>
    </item>
    
    <item>
      <title>3、异常处理的方式二：throws</title>
      <link>https://iiifox.github.io/java-core/03_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/3%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BA%8Cthrows/</link>
      <pubDate>Mon, 18 Jul 2022 17:55:29 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/03_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/3%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BA%8Cthrows/</guid>
      <description> &amp;ldquo;throws + 异常类型&amp;quot;写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！ try-catch-finally：真正的将异常给处理掉了；throws的方式只是将异常抛给了方法的调用者，并没有真正将异常处理掉。 开发中如何选择使用try-catch-finally还是使用throws？ 如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try-catch-finally方式处理 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑是用try-catch-finally方式进行处理。 </description>
    </item>
    
    <item>
      <title>3、类的成员之一：属性</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/3%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E4%B8%80%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Mon, 18 Jul 2022 17:41:21 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/3%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E4%B8%80%E5%B1%9E%E6%80%A7/</guid>
      <description>属性(成员变量) VS 局部变量 相同点 定义变量的格式：数据类型 变量名 = 变量值 先声明，后使用 变量都有其对应的作用域 不同点 在类中声明的位置不同。属性直接定义在类的一对{}内；局部变量声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量 关于权限修饰符的不同。属性可以在声明属性时，指明其权限，使用权限修饰符。常用的权限修饰符：private、public、缺省、protected。局部变量不可以使用权限修饰符。 默认初始化值的情况 属性：类的属性，根据其类型，都有默认初始化值。整型(byte、short、int、long)：0；浮点型(float、double)：0.0；字符型(char)：0(或&amp;rsquo;\u0000&amp;rsquo;)；布尔型(boolean)：false；引用数据类型(类、数组、接口)：null 局部变量：没有默认初始值。意味着，我们在调用局部变量之前，一定要显式赋值。特别地，形参在调用时，我们赋值即可。 在内存中加载的位置：属性加载在堆空间中(非static)；局部变量加载在栈空间 </description>
    </item>
    
    <item>
      <title>3、变量</title>
      <link>https://iiifox.github.io/java-core/01_java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/3%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 18 Jul 2022 16:52:20 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/01_java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/3%E5%8F%98%E9%87%8F/</guid>
      <description>变量的概念 内存中的一个存储区域 该区域的数据可以在同一类型范围内不断变化 变量是程序中最基本的存储单元，包含变量类型、变量名、存储的值 变量的作用 用于在内存中保存数据 使用变量注意 Java 中每个变量必须先声明，后使用 使用变量名来访问这块区域的数据 变量的作用域：其定义所在的一对{}内 变量只有在其作用域内才有效 同一个作用域内，不能定义重名的变量 变量的分类 按数据类型分类
基本数据类型 数值型 整数类型 (byte short int long) 浮点类型 (float double) 字符型 (char) 布尔型 (boolean) 引用数据类型 类 (class) 接口 (interface) 数组 ([]) 按声明位置分类
成员变量 实例变量 (不以 static 修饰) 类变量 (以 static 修饰) 局部变量 形参 (方法、构造器中定义的变量) 方法局部变量 (在方法内部定义) 代码块局部变量 (在代码块内定义) 整数变量：byte、short、int、long Java 各整数类型有固定的表数范围和字段长度，不受具体 OS 的影响，以保证 Java 程序的可移植性。 Java 的整型常量默认为 int 型，声明 long 型常量须加l或者L Java 程序中变量通常声明为 int 型，除非不足以表示较大的数，才使用 long 类型 占用存储空间 表数范围 byte 1字节=8bit位 -128~127 short 2字节 -32768~32767 int 4字节 -2147483648~2147483647(约21亿) long 8字节 $-2^{63}$ ~ $2^{63}-1$ bit：计算机中的最小存储单位。byte：计算机中基本存储单元。</description>
    </item>
    
    <item>
      <title>4、自定义异常类</title>
      <link>https://iiifox.github.io/java-core/03_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/4%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB/</link>
      <pubDate>Mon, 18 Jul 2022 17:54:42 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/03_%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/4%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB/</guid>
      <description> 继承于现有的异常结构：RuntimeException、Exception 提供全局常量：serialVersionUID 提供重载的构造器 </description>
    </item>
    
    <item>
      <title>4、类的成员之二：方法</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/4%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E4%BA%8C%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 18 Jul 2022 17:41:13 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/4%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E4%BA%8C%E6%96%B9%E6%B3%95/</guid>
      <description>方法的声明 权限修饰符 返回值类型 方法名(形参列表){ 方法体 } // 注意：static、final、abstract来修饰的方法，后面再讲 返回值类型：有返回值 VS 没有返回值 如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用return关键字来返回指定类型的变量或常量：“return 数据”。 如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要使用return。但是，如果使用的话，只能“return;”表示结束此方法的意思。 return 关键字的使用 使用范围：使用在方法体中 作用：1、结束方法；2、针对于有返回值类型的方法，使用&amp;quot;return 数据&amp;quot;方法返回所要的数据。 注意点：return关键字后面不可以声明执行语句。 方法的使用 方法的使用中，可以调用当前类的属性或方法。特殊的，方法A中又调用了方法A：递归方法 方法中不可以定义方法。 理解“万事万物皆对象” 在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能接口 Scanner, String等 文件：File 网络资源：URL 涉及到Java与前端Html、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类和对象。 方法的重载(overload) 重载的概念：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。 重载的特点：与返回值类型无关，只看参数列表，且参数列表必须不同（参数个数或参数类型）。调用时，根据方法参数列表的不同来区分。 // 返回两个整数的和 int add(int x, int y) {return x+y;} // 返回三个整数的和 int add(int x, int y, int z) {return x+y+z;} // 返回两个小数的和 double add(double x, double y) {return x+y;} 可变个数的形参 JavaSE 5.0中提供了Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可以变的实参。
// JDK 5.</description>
    </item>
    
    <item>
      <title>4、进制</title>
      <link>https://iiifox.github.io/java-core/01_java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/4%E8%BF%9B%E5%88%B6/</link>
      <pubDate>Mon, 18 Jul 2022 16:52:12 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/01_java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/4%E8%BF%9B%E5%88%B6/</guid>
      <description> 所有数字在计算机底层都是以二进制形式存在。 对于整数，有四种表示方式： 二进制(binary)：0,1，满2进1，以0b或0B开头 十进制(decimal)：0-9，满10进1 八进制(octal)：0-7，满8进1，以数字0开头表示 十六进制(hex)：0-9及A-F，满16进1，以0x或0X开头表示。此处的A-F不区分大小写。 Java 整数常量默认是 int 类型，当用二进制定义整数时，其第 32 位(最高位)是符号位：当是 long 类型时，二进制默认占64位，第64位是符号位 二进制的整数有如下三种形式： 原码：直接将一个数值换成二进制数。最高位是符号位 负数的反码：是对原码按位取反，只有最高位(符号位)确认为1 负数的补码：其反码加1 计算机以二进制 补码 的形式保持所有的整数 正数的原码、反码、补码都相同 负数的补码是其反码+1 </description>
    </item>
    
    <item>
      <title>5、面向对象特征之一：封装性</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%80%E5%B0%81%E8%A3%85%E6%80%A7/</link>
      <pubDate>Mon, 18 Jul 2022 17:41:04 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%80%E5%B0%81%E8%A3%85%E6%80%A7/</guid>
      <description>四种访问权限修饰符 Java权限修饰符public、protected、private置于类的成员定义前，用来限定对象对该类成员的访问权限 修饰符 类内部 同一个包 不同包的子类 同一个工程 private Yes (缺省) Yes Yes protected Yes Yes Yes public Yes Yes Yes Yes 对于class的权限修饰只可以用public和default(缺省)。
public类可以在任意地方被访问。 default类只可以被同一个包内部的类访问。 什么是封装性？ 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可拓展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出去。这就是封装性的设计思想。 封装性的体现 Java规定的四种权限（从小到大排列）：private、缺省、protected、public 4种权限可以修饰类及类的内部结构：属性、方法、构造器、内部类 具体的，4中权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类；修饰类的话，只能使用：缺省、public 总结：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小</description>
    </item>
    
    <item>
      <title>5、运算符</title>
      <link>https://iiifox.github.io/java-core/01_java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/5%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Mon, 18 Jul 2022 16:52:03 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/01_java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/5%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。
算术运算符 赋值运算符 比较运算符（关系运算符） 逻辑运算符 位运算符 三元运算符 算术运算符 运算符 运算 范例 结果 + 正号 +3 3 - 负号 b=4; -b -4 + 加 5+5 10 - 减 6-4 2 * 乘 3*4 12 / 除 5/5 1 % 取模(取余) 7%5 2 ++ 自增(前)，先运算后取值 a=2;b=++a; a=3;b=3 ++ 自增(后)，先取值后运算 a=2;b=a++; a=3;b=2 &amp;ndash; 自减(前)，先运算后取值 a=2;b=&amp;ndash;a; a=1;b=1 &amp;ndash; 自减(后)，先取值后运算 a=2;b=a&amp;ndash;; a=1;b=2 + 字符串连接 &amp;ldquo;He&amp;rdquo;+&amp;ldquo;llo&amp;rdquo; &amp;ldquo;Hello&amp;rdquo; 疑难点1：%取余运算，结果的符号与被模数的符号相同
int m1 = 12; int n1 = 5; System.</description>
    </item>
    
    <item>
      <title>6、类的成员之三：构造器</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E4%B8%89%E6%9E%84%E9%80%A0%E5%99%A8/</link>
      <pubDate>Mon, 18 Jul 2022 17:40:56 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/6%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E4%B8%89%E6%9E%84%E9%80%A0%E5%99%A8/</guid>
      <description>构造器的作用 创建对象 初始化对象的信息 说明 如果没有显示的定义类的构造器的话，则系统默认提供一个空参的构造器，默认构造器的权限修饰符与类修饰符一致 定义构造器的格式：权限修饰符 类名(形参列表){} 一个类中定义的多个构造器，彼此构成重载 一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器 一个类中，至少会有一个构造器 属性赋值的过程 默认初始化 显式初始化 构造器中的初始化 通过“对象.属性”或“对象.方法”的方式赋值 </description>
    </item>
    
    <item>
      <title>6、程序流程控制</title>
      <link>https://iiifox.github.io/java-core/01_java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/6%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 18 Jul 2022 16:51:40 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/01_java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/6%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>程序控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。 其流程控制方式采用结构化程序设计中规定的三种基本流程结果，即：顺序结构、分支结构、循环结构 分支结构 if-else结构 else 结构是可选的 针对与条件表达式： 如果多个条件表达式之间是“互斥”关系（或没有交集的关系），哪个判断和执行语句声明在上面还是下面，无所谓。 如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。 如果多个条件表达式之间有包含关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没有机会执行 if-else 结构是可以互相嵌套的。 如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。 多个if-else时，if-else的配对方式采用就近原则进行配对 switch-case结构 switch(表达式){ case 常量1: 语句1; // break; case 常量2: 语句2; // break; ... ... case 常量N: 语句N; // break; default: 语句; // break; } 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应的case结构中，调用其执行语句。当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。 break，可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构 switch结构中的表达式，只能是如下的6种数据类型之一：byte、short、char、int、枚举类型（JDK5.0新增）、String类型（JDK7.0新增） case 之后只能声明常量，不能声明范围。 break 关键字是可选的 default：相当于if-else结构中的else。default结构是可选的，而且位置是灵活的。 int number = 0; // Console: zero switch(number) { default: System.out.println(&amp;#34;other&amp;#34;); case 0: System.out.println(&amp;#34;zero&amp;#34;); break; case 1: System.out.println(&amp;#34;one&amp;#34;); break; } 凡是可以使用switch-case的结构，都可以转换为if-else。反之，不成立。 当发现既可以使用switch-case且switch中表达式的取值情况不太多，又可以使用if-else时，我们优先选择使用switch-case。原因：switch-case执行效率稍高。 循环结构 循环语句的四个组成部分</description>
    </item>
    
    <item>
      <title>7、拓展知识</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/7%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 18 Jul 2022 17:40:48 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/7%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86/</guid>
      <description>JavaBean JavaBean是一种Java语言写成的可重用组件。 所谓JavaBean，是指符合如下标准的Java类： 类是公共的 有一个无参的公共的构造器 有属性，且有对应的get、set方法 UML类图 +表示public类型，-表示private类型，#表示protected类型 方法的写法：方法的类型(+、-) 方法名(参数名: 参数类型): 返回值类型 属性：:前是属性名，:后是属性的类型 </description>
    </item>
    
    <item>
      <title>7、数组</title>
      <link>https://iiifox.github.io/java-core/01_java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/7%E6%95%B0%E7%BB%84/</link>
      <pubDate>Mon, 18 Jul 2022 16:51:21 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/01_java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/7%E6%95%B0%E7%BB%84/</guid>
      <description> 数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。 数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型。 创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址。 数组的长度一旦确定，就不能修改。 //1.一维数组的声明和初始化	int[] ids;//声明 //1.1静态初始化：数组的初始化和数组元素的赋值操作同时进行 ids = new int[]{1001,1002,1003,1004}; //1.2动态初始化：数组的初始化和数组元素的赋值操作分开进行 String[] names = new String[5]; 数组元素的默认初始化值
数组元素是整型：0 数组元素是浮点型：0.0 数组元素是char型：0或者&amp;rsquo;\u0000&amp;rsquo;，而非&#39;0&#39; 数组元素是boolean型：false 数组元素是引用数据类型：null 对于二维数组的理解：我们可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。其实，从数组底层的运行机制来看，其实没有多维数组。
//一些错误的写法 //int[] ids; //ids = {1,2,2}; //编译错误 //一些正确但是不标准的写法 int[] arr1 = {1,2,2,3}; //类型推断 int[] arr2[] = new int[][]{{1,2,2},{4,5},{6,7,8}}; // 数组[]位置可以随意 int[] arr3[] = {{1,2,2},{4,5},{6,7,8}}; String[] strArray1[] = {{&amp;#34;222&amp;#34;, &amp;#34;2222&amp;#34;},{&amp;#34;111&amp;#34;, &amp;#34;3333&amp;#34;, &amp;#34;5555&amp;#34;}}; </description>
    </item>
    
    <item>
      <title>8、关键字：this</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/8%E5%85%B3%E9%94%AE%E5%AD%97this/</link>
      <pubDate>Mon, 18 Jul 2022 17:40:39 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/8%E5%85%B3%E9%94%AE%E5%AD%97this/</guid>
      <description>this可以用来修饰、调用：属性、方法、构造器
this修饰属性和方法时可以理解为：当前对象或当前正在创建的对象
在类的方法中，我们可以使用“this.属性”或者“this.方法”的方式，调用当前对象属性或方法。但是通常情况下，我们都选择省略&amp;quot;this.&amp;quot;。特殊情况下，如果方法的形参和类的属性同名时，我们必须显示的使用“this.变量”的方式，表明此变量是属性，而非形参。 在类的构造器中，我们可以使用“this.属性”或“this.方法”的方式，调用当前正在创建的对象属性或方法，但是通常情况下，我们都选择省略&amp;quot;this.&amp;quot;。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用“this.变量”的方式，表明此变量是属性，而非形参。 this调用构造器
我们在类的构造器中，可以显式的使用“this(形参列表)”方式，调用本类中指定的其他构造器
构造器中不能通过“this(形参列表)”方式调用自己
如果一个类中有n个构造器，则最多有n-1个构造器中使用了“this(形参列表)”
规定，“this(形参列表)”必须声明在当前构造器的首行，因此构造器内部，最多只能声明一个“this(形参列表)”，用来调用其他的构造器</description>
    </item>
    
    <item>
      <title>附加：Arrays工具类的使用</title>
      <link>https://iiifox.github.io/java-core/01_java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E9%99%84%E5%8A%A0arrays%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 18 Jul 2022 16:50:45 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/01_java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E9%99%84%E5%8A%A0arrays%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description> java.util.Arrays类即为操作数组的工具类，包含了用来操作数组的各种方法 方法 作用 boolean equals(int[] a,int[] b) 判断两个数组是否相等 String toString(int[] a) 输出数组信息 void fill(int[] a,int val) 将指定值填充到数组之中 void sort(int[] a) 对数组进行排序 int binarySearch(int[] a,int key) 对排列后的数组进行二分法检索指定的值 </description>
    </item>
    
    <item>
      <title>9、关键字：package</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/9%E5%85%B3%E9%94%AE%E5%AD%97package/</link>
      <pubDate>Mon, 18 Jul 2022 17:40:29 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/9%E5%85%B3%E9%94%AE%E5%AD%97package/</guid>
      <description>this可以用来修饰、调用：属性、方法、构造器
this修饰属性和方法时可以理解为：当前对象或当前正在创建的对象
在类的方法中，我们可以使用“this.属性”或者“this.方法”的方式，调用当前对象属性或方法。但是通常情况下，我们都选择省略&amp;quot;this.&amp;quot;。特殊情况下，如果方法的形参和类的属性同名时，我们必须显示的使用“this.变量”的方式，表明此变量是属性，而非形参。
在类的构造器中，我们可以使用“this.属性”或“this.方法”的方式，调用当前正在创建的对象属性或方法，但是通常情况下，我们都选择省略&amp;quot;this.&amp;quot;。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用“this.变量”的方式，表明此变量是属性，而非形参。
this调用构造器
我们在类的构造器中，可以显式的使用“this(形参列表)”方式，调用本类中指定的其他构造器
构造器中不能通过“this(形参列表)”方式调用自己
如果一个类中有n个构造器，则最多有n-1个构造器中使用了“this(形参列表)”
规定，“this(形参列表)”必须声明在当前构造器的首行，因此构造器内部，最多只能声明一个“this(形参列表)”，用来调用其他的构造器</description>
    </item>
    
    <item>
      <title>10、关键字：import</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/10%E5%85%B3%E9%94%AE%E5%AD%97import/</link>
      <pubDate>Mon, 18 Jul 2022 17:40:21 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/10%E5%85%B3%E9%94%AE%E5%AD%97import/</guid>
      <description> 在源文件中使用import显示的导入指定包下的类或接口 声明在包的声明和类的声明之间 如果需要导入多个类或者接口，那么就并列显式多个import语句即可 举例：可以使用java.util.*的方式，一次性导入util包下的所有的类或接口 如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句 如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的是哪个类 如果已导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。 import static组合的使用：调用指定类或接口下的静态的属性或方法 </description>
    </item>
    
    <item>
      <title>11、面向对象特征之二：继承性</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/11%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%BA%8C%E7%BB%A7%E6%89%BF%E6%80%A7/</link>
      <pubDate>Mon, 18 Jul 2022 17:40:12 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/11%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%BA%8C%E7%BB%A7%E6%89%BF%E6%80%A7/</guid>
      <description>继承性的好处 减少了代码的冗余，提高了代码的复用性 便于功能的拓展 为之后多态性的使用，提供了前提 继承性的说明 继承性的格式： class A extends B{} 体现：一旦子类A继承父类B以后，子类A中就获取了父类B中的声明的所有的属性和方法。特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中的私有的结构。只是因为封装性的影响，使得子类不能直接调用父类的结构而已。 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展 Java中关于继承性的规定 一个类可以被多个子类继承 Java中类的单继承性：一个类只能有一个父类 子父类是相对的概念 子类直接继承的父类称为直接父类；间接继承的父类称为间接父类 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法 补充说明
如果我们没有显示的声明一个类的父类的话，则此类继承于java.lang.Object类 所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类 意味着，所有的java类都具有java.lang.Object类声明的功能。 方法的重写(override/overwrite) 重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作 应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法 重写的规定 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符 特殊情况：子类不能重写父类中声明为private权限的方法 返回值类型： 父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类 父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的。 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型 子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）。 </description>
    </item>
    
    <item>
      <title>12、关键字：super</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/12%E5%85%B3%E9%94%AE%E5%AD%97super/</link>
      <pubDate>Mon, 18 Jul 2022 17:39:59 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/12%E5%85%B3%E9%94%AE%E5%AD%97super/</guid>
      <description> super可以用来调用：属性、方法、构造器 super的使用 我们可以在子类的方法或构造器中。通过使用&amp;quot;super.属性&amp;quot;或&amp;quot;super.方法&amp;quot;的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略&amp;quot;super.&amp;quot; 特殊情况：当子类和父类中定义了同名的属性时，我们要想要在子类中调用父类中声明的属性，则必须显式的使用&amp;quot;super.属性&amp;quot;的方式，表明调用的是父类中声明的属性，否则默认是调用子类的属性。 特殊情况：当子类重写了父类中的方法以后，我们想在子类中的方法中调用父类中被重写的方法时，则必须显式使用&amp;quot;super.方法&amp;quot;的方式，表明调用的是父类中被重写的方法，否则默认是调用子类的方法。 super调用构造器 我们可以在子类的构造器中显式的使用&amp;quot;super(形参列表)&amp;ldquo;的方式，调用父类中声明的指定的构造器 &amp;ldquo;super(形参列表)&amp;ldquo;的使用，必须声明在子类构造器的首行 我们在类的构造器中，针对于&amp;quot;this(形参列表)&amp;ldquo;或&amp;quot;super(形参列表)&amp;ldquo;只能二选一，不能同时出现 在构造器的首行，没有显示的声明&amp;quot;this(形参列表)&amp;ldquo;或&amp;quot;super(形参列表)&amp;quot;，则默认调用的是父类中的空参的构造器 在类的多个构造器中，至少有一个类的构造器中使用了&amp;quot;super(形参列表)&amp;quot;，调用父类中的构造器 子类对象实例化的全过程 从结果上来看：（继承性） 子类继承父类以后，就获取了父类中声明的属性或方法。 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性 从过程上来看： 当我们通过父类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。 明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。 </description>
    </item>
    
    <item>
      <title>13、面向对象特征之三：多态性</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%89%E5%A4%9A%E6%80%81%E6%80%A7/</link>
      <pubDate>Mon, 18 Jul 2022 17:39:47 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/13%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%89%E5%A4%9A%E6%80%81%E6%80%A7/</guid>
      <description> 理解多态性：可以理解为一个事物的多种形态。 何为多态性： 对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用） 多态的使用，虚拟方法调用 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。 总结：编译，看左边；运行，看右边。 多态性的使用前提： 类的继承关系 方法的重写 对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边） 区分方法的重载与重写 二者定义的不同： 重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。 重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作 从编译和运行的角度看： 重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。 所以：对于重载而言，在方法调用之前，编译期就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定” 而对于多态，只有等到方法调用的那一刻，解释器运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 instanceof 操作符 instanceof 关键字的使用：a instanceof A：判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false 使用情境： 为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，就不进行向下转型。 如果类B是类A的父类，且a instanceof A返回true，则a instanceof B也返回true ==和equals的区别 ==既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址 equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是==；我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点 具体要看自定义类里有没有重写Object的equals方法来判断 通常情况下，重写equals方法，会比较类中的相应属性是否都相等 Java中的JUnit单元测试 创建Java类，进行单元测试。此时的Java类要求： 此类是public的 此类提供公共的无参的构造器 此类中声明单元测试方法。此时的单元测试方法的权限是public，没有返回值，没有形参 此单元测试方法上需要声明注解：@Test 写完代码后，左键双击单元测试方法名，右键：run as - JUnit Test 说明：如果执行结果没有任何异常：绿条；如果执行结果出现异常：红条 </description>
    </item>
    
    <item>
      <title>14、包装类（Wrapper）的使用</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/14%E5%8C%85%E8%A3%85%E7%B1%BBwrapper%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 18 Jul 2022 17:39:36 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/14%E5%8C%85%E8%A3%85%E7%B1%BBwrapper%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
      <description>基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double boolean Boolean char Character Byte、Short、Integer、Long、Float、Double的父类为Number；Boolean、Character的父类为Object
基本类型、包装类与String类间的转换 基本数据类型 &amp;ndash;&amp;gt; 包装类：自动装箱 包装类 &amp;ndash;&amp;gt; 基本数据类型：自动拆箱 基本数据类型 &amp;ndash;&amp;gt; String类：String类的valueOf()方法 String类 &amp;ndash;&amp;gt; 基本数据类型：调用相应包装类的parseXxx(String)静态方法 包装类 &amp;ndash;&amp;gt; String类：包装类对象的toString()方法 // 使用parseBoolean时，如果s非空且在忽略大小写的情况下等于true，则返回true；否则返回false public static boolean parseBoolean(String s) { return &amp;#34;true&amp;#34;.equalsIgnoreCase(s); } // 三元运算符运算过程中会尽量使两边的类型一致，所以new Integer(1)被自动提升了类型 Object o1 = true ? new Integer(1) : new Double(2.0); System.out.println(o1); // 1.0 Object o2; if (true) { o2 = new Integer(1); } else { o2 = new Double(2.</description>
    </item>
    
    <item>
      <title>15、关键字：static</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/15%E5%85%B3%E9%94%AE%E5%AD%97static/</link>
      <pubDate>Mon, 18 Jul 2022 17:39:26 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/15%E5%85%B3%E9%94%AE%E5%AD%97static/</guid>
      <description> 使用static修饰属性：静态变量（或类变量） 属性，按是否使用static修饰，又分为：静态属性 vs 非静态属性（实例变量） 实例变量：我们创建了类的多个对象，每个对象都独立拥有一套类中的非静态属性。当修改其中一个对象的非静态属性时，不会导致其他对象中同样的属性值修改 静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的 static修饰属性的其他说明 静态变量随着类的加载而加载。可以通过&amp;quot;类.静态变量&amp;quot;的方式进行调用 静态变量的加载要早于对象的创建 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中 使用static修饰方法：静态方法 随着类的加载而加载，可以通过&amp;quot;类.静态方法&amp;quot;的方式进行调用 静态方法中，只能调用静态的方法或属性；非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性 static注意点 在静态的方法内，不能使用this关键字、super关键字 开发中，如何确定一个属性是否要声明为static的？ 属性可以被多个对象所共享的，不会随着对象的不同而不同 类中的常量也常常声明为static 开发中，如何确定一个方法是否要声明为static的？ 操作静态属性的方法，通常设置为static的 工具类中的方法，习惯上声明为static的 /** * 单例设计模式： * 1、所谓的类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。 * 2、如何实现？ * 饿汉式 vs 懒汉式 * 3、区分饿汉式和懒汉式 * 饿汉式： * 坏处：对象加载时间过长。 * 好处：饿汉式是线程安全的 * 懒汉式： * 好处：延迟对象的创建。 * 目前的写法坏处：线程不安全。(到多线程内容时，再修改) */ // 饿汉式 class Bank { // 1、私有化类的构造器 private Bank() { } // 2、内部创建类的对象 // 4、要求此对象也必须声明为静态的 private static Bank instance = new Bank(); // 3、提供公共的静态的方法，返回类的对象 public static Bank getInstance() { return instance; } } // 懒汉式 class Order { // 1、私有化类的构造器 private Order() { } // 2、声明当前类对象，没有初始化 // 4、此对象也必须声明为static的 private static Order instance = null; // 3、声明public、static的返回当前类对象的方法 public static Order getInstance() { if (instance == null) { instance = new Order(); } return instance; } } </description>
    </item>
    
    <item>
      <title>16、类的成员之四：代码块（或初始化块）</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/16%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E5%9B%9B%E4%BB%A3%E7%A0%81%E5%9D%97%E6%88%96%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97/</link>
      <pubDate>Mon, 18 Jul 2022 17:39:15 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/16%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E5%9B%9B%E4%BB%A3%E7%A0%81%E5%9D%97%E6%88%96%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97/</guid>
      <description>代码块的作用：用来初始化类、对象 代码块如果有修饰的话，只能使用static 分类：静态代码块 VS 非静态代码块 静态代码块 内部可以有输出语句 随着类的加载而执行，而且只执行一次 作用：初始化类的信息 如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行 静态代码块的执行要优先于非静态代码块的执行 静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构 非静态代码块 内部可以有输出语句 随着对象的创建而执行 每创建一个对象，就执行一次非静态代码块 作用：可以在创建对象时，对对象的属性等进行初始化 如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行 非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法 总结：由父及子，静态先行
属性赋值的过程 默认初始化 显式初始化/在代码块中赋值 构造器中初始化 有了对象以后，可以通过&amp;quot;对象.属性&amp;quot;或&amp;quot;对象.方法&amp;quot;的方式，进行赋值 显式初始化和在代码块中赋值的顺序先后取决于代码先后顺序</description>
    </item>
    
    <item>
      <title>17、关键字：final</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/17%E5%85%B3%E9%94%AE%E5%AD%97final/</link>
      <pubDate>Mon, 18 Jul 2022 17:39:05 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/17%E5%85%B3%E9%94%AE%E5%AD%97final/</guid>
      <description>final可以用来修饰的结构：类、方法、变量 final用来修饰一个类：此类不能被其他类所继承。 final用来修饰方法：表明此方法不可以被重写 final用来修饰变量：此时的&amp;quot;变量&amp;quot;就称为是一个常量 final修饰属性：可以考虑赋值的位置有：显示初始化、代码块中初始化、构造器中初始化 final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。 static final 用来修饰属性：全局变量</description>
    </item>
    
    <item>
      <title>18、关键字：abstract</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/18%E5%85%B3%E9%94%AE%E5%AD%97abstract/</link>
      <pubDate>Mon, 18 Jul 2022 17:38:48 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/18%E5%85%B3%E9%94%AE%E5%AD%97abstract/</guid>
      <description> abstract可以用来修饰的结构：类、方法 abstract修饰类：抽象类 此类不能实例化 抽象类中一定要有构造器，便于子类实例化时调用(涉及：子类对象实例化的全过程) 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 abstract修饰方法：抽象方法 抽象方法只要方法的声明，没有方法体 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。 若子类重写了父类中的所有抽象方法后，此子类才可以实例化；若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰 注意点：abstract不能用来修饰：属性、构造器等结构；abstract不能用来修饰私有方法、静态方法、final的方法、final的类
匿名对象 method(new Student()); //匿名对象 Worker worker = new Worker(); method1(worker); //非匿名的类非匿名的对象 method1(new Worker()); //非匿名的类匿名的对象 // 创建匿名子类的非匿名对象 Person p = new Person() { @Override public void eat() { System.out.println(&amp;#34;吃东西&amp;#34;); } } // 创建匿名子类的匿名对象 method1(new Person() { @Override public void eat() { System.out.println(&amp;#34;吃东西&amp;#34;); } }); </description>
    </item>
    
    <item>
      <title>19、关键字：interface</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/19%E5%85%B3%E9%94%AE%E5%AD%97interface/</link>
      <pubDate>Mon, 18 Jul 2022 17:36:49 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/19%E5%85%B3%E9%94%AE%E5%AD%97interface/</guid>
      <description>Java中，接口和类是并列的两个结构 如何定义接口，定义接口中的成员: JDK7及以前：只能定义全局变量和抽象方法: 全局常量：public static final的，但是书写时，可以省略不写 抽象方法：public abstract的 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法 接口中不能定义构造器！意味着接口不可以实例化 Java开发中，接口通过让类去实现(implements)的方式来使用。如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化；如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类。 Java类可以实现多个接口：弥补了Java单继承性的局限性。格式：class AA extends BB implements CC,DD,EE 接口与接口之间可以继承，而且可以多继承。格式：interface AA extends BB,CC 接口的具体使用，体现了多态性 接口，实际上可以看做是一种规范 interface Flyable { // 全局变量 public static final int MAX_SPEED = 7900; int MIN_SPEED = 1; // 省略了public static final // 抽象方法 public abstract void fly(); // 省略了public abstract void stop(); // Interfaces cannot have constructors // public Flyable() {} } interface A { int x = 0; } class B { int x = 1; } class C extends B implements A { public void pX() { // 编译不通过，因为x是不明确的 // System.</description>
    </item>
    
    <item>
      <title>20、类的内部成员之五：内部类</title>
      <link>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/20%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E6%88%90%E5%91%98%E4%B9%8B%E4%BA%94%E5%86%85%E9%83%A8%E7%B1%BB/</link>
      <pubDate>Mon, 18 Jul 2022 17:36:12 +0800</pubDate>
      
      <guid>https://iiifox.github.io/java-core/02_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/20%E7%B1%BB%E7%9A%84%E5%86%85%E9%83%A8%E6%88%90%E5%91%98%E4%B9%8B%E4%BA%94%E5%86%85%E9%83%A8%E7%B1%BB/</guid>
      <description>Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类
内部类的分类：成员内部类（静态、非静态） VS 局部内部类（方法内、代码块内、构造器内）
成员内部类：
作为外部类的成员： 调用外部类的结构 可以被static修饰 可以被4种不同的权限修饰 作为一个类： 类内可以定义属性、方法、构造器等 可以被final修饰，表示此类不能被继承。言外之意，不使用final就可以被继承 可以被abstract修饰 如何实例化成员内部类的对象
// 创建Dog实例（静态的成员内部类）： Person.Dog dog = new Person.Dog(); dog.show(); // 创建Bird实例（非静态的成员内部类）： // Person.Bird bird = new Person.Bird(); // 编译错误 Person p = new Person(); Person.Bird bird = p.new Bird(); bird.sing(); 如何在成员内部类中区分调用外部类的结构 public void sing() { // 调用外部类的非静态方法 Person.this.eat(); eat(); // 调用外部类的非静态属性 System.out.println(age); } public void display(String name) { System.out.println(name); // 方法的形参 System.out.println(this.name); // 内部类的属性 System.out.println(Person.this.name); // 外部类的属性 } 开发中局部内部类的使用 public Comparable getComparable() { return new Comparable() { @Override public int compareTo(Object o) { return 0; } } } 在局部内部类的方法中(比如：show)，如果要调用外部类所声明的方法(比如：method)中的局部变量(比如：num)的话，要求此局部变量声明为final的。 JDK 7及之前版本：要求此局部变量显式的声明为final的 JDK 8及之后版本：可以省略final的声明 public void method() { //局部变量-JDK 8及之后，final可以省略 final int num = 10; class AA { public void show () { // num = 20; System.</description>
    </item>
    
  </channel>
</rss>
